## Mastering JSON (JavaScript Object Notation)
Widely hailed as the successor to XML in the browser, JSON aspires to be nothing more than a simple, and elegant data format for the exchange of information between the browser and server; and in doing this simple task it will usher in the next verion the World Wide Web itself.

### The Object : An Introduction
Behold, an Object...

	var MyFirstObject = {};

It may not look like much, but those squiggly braces have the potential to record every bit of information humanity has ever gathered, and express the most complex programs computer scientists can dream up. In fact, JavaScript itself is stored inside of a set of squiggly braces just like that, as are all of its primitive data types -- strings, numbers, arrays, dates, regular expressions, they're all objects and they all started out just like myFirstObject.

### Creating A New Object
The old way to create a new object was to use the "new" keyword.

	var myJSON = new Object();

This method has been `deprecated` now in favor of simply defining an empty object with squiggly braces...

	var myJSON = {};

### Objects as Data
At its most base level a JavaScript Object is a very flexible and robust data format expressed as "name/value pairs". That is, an object holds a name which is an object's property -- think of it as a plain old variable name that's attached to the object name,. And the object holds the value of that name. Here's an example...

	var myFirstJSON = {
				"firstName" : "John",
				"lastName"  : "Doe",
				"age"	    : 23
							};

	document.writeln(myFirstJSON.firstName);	// Outputs John
	document.writeln(myFirstJSON.lastName);		// Outputs Doe
	document.writeln(myFirstJSON.age);		// Outputs 23

This object has 3 properties or name/value pairs. The name is a string -- in our example, firstName, lastName, and age. The value can be any JavaScript object (and remember everything in JavaScript is an object so the value can be a string, number, array, function, even other Objects) -- In this example our values are John, Doe, and 23. John and Doe are strings but age is a number and as you can see this is not a problem.

This data format is called JSON for JavaScript Object Notation. What makes it particularly powerful is that since the value can be any data type, you can store other arrays and other objects, nesting them as deeply as you need.

Here is an example of a somewhat complex JSON structure ...

	var employees = {
				"accounting" : 	[	// accounting is an array in employees.
							{
								"firstName" : "John",	// First element
								"lastName"  : "Doe",
								"age:	    : 23
							},

							{
								"firstName" : "Mary",	// Second element
								"lastName"  : "Smith",
								"age:	    : 32
							},
						],	// End "accounting" array.
				"sales" : 	[	// Sales is another array in employees.
							{
								"firstName" : "Sally",	// First element
								"lastName"  : "Green",
								"age:	    : 23
							},

							{
								"firstName" : "Jim",	// Second element
								"lastName"  : "Galley",
								"age:	    : 41
							},
						],	// End "sales" array.
			} // End Employees

Here employees is an object. That object has two properties or name/value pairs. Accounting is an array which holds two JSON objects showing the name and age of 2 employees. Likewise sales is also an array which holds two JSON objects showing the name and age of the two employees who work in sales. All of this data exists within the employees object. There are several different ways to access this data.

### Accessing Data In JSON
The most common way to access JSON data is through `dot notation`. This is simply the object name followed by a period and then followed by the name/property you would like to access.

	var myObject = { 'color' : 'blue' };
	document.writeln(myObject.color);	// outputs blue.

If your object contains an object then just add another period and name...

	var myObject = {
				'color'  : 'blue',
				'animal' : { 'dog' : 'friendly' }
			};
	
	document.writeln(myObject.animal.dog);	// outputs friendly

Using the "employee" example above, if we wanted to access the first person who worked in sales...

	document.writeln(employee.sales[0].firstName + ' ' + employees.sales[0].lastName);

We can also access the second person who works in "accounting".

	document.writeln(employee.accounting[1].firstName + ' ' + employee.accounting[1].lastName);

To recap, the "employee" example is an object which holds two arrays each of which holds two addtional objects. The only limits to the structure are the amount of storage and memory available to it. Because JSON can store objects within objects within objects and arrays within arrays that can also store objects, there is no virtual limit to what a JSON object can store. Given enough moemory and storage requirement, a simple JSON data structure can store and properly index, all the information ever generated by humainty.

### Simulating An Associative Array
You can also access JSON data as if it were `Associative Array`.

	var myFirstJSON = {
				"firstName" : "John",
				"lastName"  : "Doe",
				"age"	    : 23
				};

	document.writeln(myFirstJSON["firstName"]);		// Outputs John
	document.writeln(myFirstJSON["lastName");		// Outputs Doe
	document.writeln(myFirstJSON["age"]);			// Outputs 23

Be aware that this is **NOT** an associative array, however it appears. If you attempt to loop through myFirstObject you will get, in addition to the three properties above, andy methods or prototypes assigned to the object, so while you're more than free to use thie method of addressign JSON data, just treat it for what it is (Object Properties) and not for what it is not (Associative Array).

### Receiving JSON via AJAX
There are three seperate ways to receive JSON data via AJAX.

 * Assignment
 * Callback
 * Parse

#### JSON Via Assignment
There's no standard naming convention for these methods, however "assignment method" is a good descriptive name because the file comming in from the server creates a javascript expression which will assign the JSON object to a variable. When the responseText from the server is passed through eval, someVar will be loaded with the JSON object and you can access it from there.

	var JSONFile = "someVar = { 'color' : 'blue' }";	// example of what is received from the server.
	eval(JSONFile);						// Execute the javascript code contained in JSONFile.

	document.writeln(someVar.color);			// Outputs 'blue'

#### JSON Via Callback
The second method calls a pre-defined function and passes the JSON data to that function as the first argument. A good name for this method is the **"callback method"**. This approach is used extensively when dealing with third party JSON files (IE, JSON data from domains you do not control).

	function processData(incommingJSON) {
		document.writeln(incommingJSON.color);		// Outputs 'blue'
	}

	// exmple of what is received from the server ...
	var JSONFile = "processData( { 'color' : 'blue' } )";

	eval(JSONFile);

#### JSON Via Parse
The third and final method sends a raw object which must be parsed by a function. This could be referred to as the **"parse method"**. This is, by far, the safest and most secure way to transfer JSON data and it will be a part of the next version of JavaScript due to be released in 2008. For now, it is, unfortunately, limited only to domains which you control.

	// The following block implements the string.parseJSON method
	(
		function (s) {
			// This prototype has been released into the Public Domain, 2007-03-20
			// Original Authorship: Douglas Crockford
			// Originating Website: http://www.JSON.org
			// Originating URL    : http://www.JSON.org/JSON.js

			// Argument String.prototype. We do this in an immediate anonymous
			// function to avoid defining global variables.

			// m is a table of character subsitutions.
			
			var m = {
				'\b': '\\b',
				'\t': '\\t',
				'\n': '\\n',
				'\f': '\\f',
				'\r': '\\r',
				'"' : '\\"',
				'\\': '\\\\',
			};

			s.parseJSON = function (filter) {
				// Parsing happens in three stages. In the first stage, we run the text against 
				// a regular expression which looks for non-JSON characters. We are especially
				// concerned with '()' and 'new' because they can cause invocation, and '='
				// because it can cause mutation. But just to be safe, we will reject all
				// unexpected characters.

				try {
					if (/^("(\\.|[^"\\\n\r])*?"|[,:{}\[\]0-9.\-+Eaeflnr-u \n\r\t])+?$/.
				        	test(this)) {
						
						// In the second stage we use the eval function to compile the text into a 
						// JavaScript structure. The '{' operator is subject to a syntactic ambiguity
						// in JavaScript: it can begin a block or an object literal. We wrap the text
						// in parens to eliminate the ambiguity.

						var j = eval('(' + this + ')');
	
						// In the optional third stage, we recursively walk the new structure, passing
						// each name/value pair to a filter function for possible transfomation.

						if (typeof filter == 'function') {
						
							function walk(k, v) {
								if (v && typeof v == 'object' {
									for (var i in v) {
										if (v.hasOwnProperty(i)) {
											v[i] = walk(i, v[i]);
										}
									}
								}
								return filter(k, v);
							}
					
							j = walk('', j);
						}
						return j;
					}
				} catch (e) {
				// Fall through if the regexp test fails.
				}
				throw new SyntaxError("parseJSON");
			};	
		}
	) (String.prototype);
	// End public domain parseJSON block

	// begin sample code (still public domain tho)
	JSONData = '{}';			// Example of what is received from the server.
	testObject = JSONData.parseJSON();
	document.writeln(testObject.color);	// Outputs: Green.

As you can see, you'll need to include the public domain prototype which will parse the JSON data, however once it's included, processing JSON data is as simple as it looks in the last three lines of the above example. Of the three extraction methods, the "parse method" is the most secure and exposes your code to the fewest problems. You should use this method wherever possible in all of your JSON request via AJAX.

	上面的 JSON Via Parse 基本上是 Douglas Crockford 的那个版本。大概的意思是明白了，就差很多细节性的东西了。


