# Recursion vs Non-Recursion

    Chapter 2 -> Recursion and Non-Recursion 

一个较大的程序包含若干个具有独立功能的模块，每一个模块实现一个特定的功能，这才是良好的程序设计风格。

在 C 语言中，通过函数实现模块的功能，一个 C 语言程序由一个主函数和若干个函数组成。

`递归` 是 C 语言程序设计中常见的函数调用形式，也是 C 语言的一个重点和难点。

本节内容包括：

* 函数调用
* 递归与递归调用
* 一般递归转化为非递归

## 函数的递归调用
`函数的递归调用` 指的是在调用一个函数的过程中，又出现了对函数自身的调用，这种函数称为 `递归函数` 。

递归调用分为：

* 直接递归调用

    一个函数在函数定义体内直接调用自己称为直接递归调用。

* 间接递归调用

    一个函数经过一系列的中间调用，通过其它函数调用自己称为间接递归调用。

实际上，在用递归解决问题时，递归函数只知道怎样解决最简单的问题，我们称此类问题为 `基本问题`。

递归函数在解决基本问题时只是返回一个值，在解决比较复杂的问题时，与解决简单问题类似，可以通过简单
问题的答案得到复杂问题的答案。递归解决问题就是把原有问题变成比原有问题简单的问题，这样，需要解决
的问题就越来越简单、规模也越来越小，最后把问题变成一个基本问题，基本问题的答案是已知的，基本问题
解决后，比基本问题大一点的问题也得到解决，直到原有问题得到解决。

比如关于 `n!` 的求解问题。

## 递归应用举例

### 2.1 递归实现前 n 个自然数的和
参看

    iteration.c

这个文件名有问题。

### 2.2 打印输出 n 的阶乘 n!
参看

    factorial.c

## 一般递归转化为非递归
通过分析 `2.1` 的递归实现，可以把一般递归转化为非递归。其非递归代码实现如下：

	#include <stdio.h>

	int NonRecSum(int a[], int n)
	/* 非递归求数组 a 的前 n 个数的和 */
	{
			int i, sum = 0;

			for (i = 0; i < n; i++)
			{
					sum += a[i];
			}
			return sum;
	}

	int main()
	{
			int arr[] = {1, 2, 3, 4, 5, 6};
			int ret = 0;
			ret = NonRecSum(arr, 6);
			printf("%d\n", ret);
	}

上面的这个方法实现求某一数组前 n 项和的作用。如果要求前 n 项自然数的和，则更简单，使用下面的形式即可：

	#include <stdio.h>

	int NonRecSum(int n)
	{
			int i, sum = 0;

			for (i = 0; i < n; i++)
			{
					sum += i;
			}

			return sum;
	}

	int main()
	{
			int ret = 0;
			ret = NonRecSum(6);
			printf("%d\n", ret);
	}

**递归与迭代**

    迭代和递归是程序设计中常用的两种结构。任何能使用递归解决的问题都能使用迭代的方法解决。
    迭代和递归的区别是：
        1. 迭代使用循环结构，递归使用的是选择结构；
        2. 递归能使程序的结构更清晰，更简洁、更容易让人理解；
    但是，递归也有许多不足之处：
        1. 大量的递归调用会耗费大量的时间和大量的内存；
        2. 每次递归调用都会建立函数的一份拷贝，会占用大量的内存空间；
        3. 迭代则不需要反复调用函数和占用额外的内存。


