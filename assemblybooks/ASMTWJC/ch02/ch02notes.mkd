# 第 2 章 8086/8088 CPU 的内部结构与汇编语言程序上机
本章主要内容：

1. 介绍 `8086/8088` CPU 的内部结构；
2. 阐述 `8086/8088` CPU 内部各个寄存器的功能及用途；
3. 讲解 `8086/8088` CPU 的存储器结构。

最后简单介绍了汇编语言程序设计的基本方法，并给出两个汇编语言程序实例。

## 2.1 8086/8088 CPU 的功能结构
`中央处理器 CPU 的任务是执行存放在存储器里的指令序列。` CPU 一般由 `运算器` 和 `控制器` 两部分组成，在微机中也常称为
`微处理器`。

`8086/8088` CPU 按功能可分为两个独立的部件：

* 总线接口单元 BIU (Bus Interface Unit)
* 执行单元 EU (Execution Unit)

### BIU
`BIU` 单元负责完成 

1. `8086/8088` CPU 与存储器之间的信息传送；
2. 总线控制；
3. I/O 数据传送；
4. 逻辑地址与物理地址转换；
5. 从存储器中取指令送至指令流队列排队；
6. 取出执行指令时所需的操作数，并传送给 `EU` 单元完成运算和操作。

### EU
`EU` 单元负责对来自指令流队列中的指令译码并执行，实施算术逻辑运算操作。

### 指令流水线
由于 `BIU` 和 `EU` 是两个相对独立的部件，因此取指令和执行指令可以并行完成，形成指令流水线结构。

指令流结构大大减少了 CPU 等待取指令的时间，提高了 CPU 的利用率和系统运行速度。

## 2.2 8086/8088 的寄存器结构
`8086/8088` CPU 共有 **14** 个 **16** 位寄存器，一般分为 4 类：

1. 数据寄存器；
2. 段寄存器；
3. 控制寄存器；
4. 指针寄存器。

具体分类如下：

    8086/8088 寄存器
      ├─通用寄存器
      │  ├─数据寄存器
      │  │  ├─AX -> |AH|AL|
      │  │  ├─BX -> |BH|BL|
      │  │  ├─CX -> |CH|CL|
      │  │  └─DX -> |DH|DL|
      │  ├─指针寄存器
      │  │  ├─堆栈指针寄存器
      │  │  │  └─SP
      │  │  └─基址变址寄存器
      │  │     └─BP
      │  └─变址寄存器
      │     ├─源变址寄存器
      │     │  └─SI
      │     └─目的变址寄存器
      │        └─DI
      ├─控制寄存器
      │  ├─指令指针寄存器
      │  │  └─IP
      │  └─标志寄存器
      │  	  └─FR
      └─段寄存器
          ├─代码段寄存器
          │  └─CS
          ├─数据段寄存器
          │  └─DS
          ├─附加段寄存器
          │  └─ES
          └─堆栈段寄存器
             └─SS

这些寄存器具有重要的作用，专门用于存放指令执行时需要的各种信息，如

* 操作数；
* 操作数地址；
* 中间计算结果。

### 2.2.1 数据寄存器 （Data Segment Register -> DS）
数据寄存器共有 4 个 16 位寄存器，即 `AX` `BX` `CX` `DX`，通常用来暂存计算过程中的操作数、运算结果或其他信息。它们既可以
作为一个 16 位的寄存器使用，也可以作为两个 8 位的寄存器分开使用。当它们作为两个 8 位寄存器用时，按高低字节分。

高 8 位寄存器命名为

* AH
* BH
* CH
* DH

低 8 位寄存器命名为

* AL
* BL
* CL
* DL

数据寄存器除了上述用途外，还有各自的专门用途。

#### AX (Accumulator) -> 累加器
它是算术运算的主要寄存器。此外还可以作为

* 乘法运算
* 除法运算
* 输入/输出指令的专用寄存器

#### BX (Base) -> 基址寄存器
该寄存器常用于存放存储区的起始地址。

#### CX (Count) -> 计数寄存器
该寄存器常用于循环操作或字符串操作过程中的计数。

#### DX (Data) 
该寄存器常与 `AX` 配合，用于双字长运算，`DX` 存放高位字，`AX` 存放低位字。此外，还可用于输入/输出指令中存放外部设备
接口的端口地址。

* [x86 memory segmentation -> DS](http://en.wikipedia.org/wiki/X86_memory_segmentation)
* [X86 Assembly/X86 Architecture](http://en.wikibooks.org/wiki/X86_Assembly/X86_Architecture)
* [Memory data register](http://en.wikipedia.org/wiki/Memory_data_register)

### 2.2.2 段寄存器 -> (Segment Register)
为了运用所有的内存空间，`8086/8088` CPU 设定了 4 个段寄存器，分别为：

* CS
* DS
* ES
* SS

专门用于保存段首地址。

#### CS (Code Segment) -> 代码段寄存器
该寄存器用于存放正在或者正待执行的程序的段首址，其值为代码段的段值。

#### DS (Data Segment) -> 数据段寄存器
该寄存器用于存放正在或正待执行的数据段的段首址，其值为数据段的段值。

#### ES (Extra Segment) -> 附加段寄存器
该寄存器用于存放正在或正待执行的附加段的段首址，其值为附加数据段的段值。

#### SS (Stack Segment) -> 堆栈段寄存器
该寄存器用于存放正在或正待执行的堆栈段的段首址，其值为堆栈段的段值。

通常情况下

1. `CS` 划定并控制当前程序区；
2. `DS` 和 `ES` 划定并控制数据区；
3. `SS` 划定并控制堆栈区；

#### 段寄存器使用约定
|访问存储区类型    	|缺省段寄存器	|可指定段寄存器	|段内偏移地址来源	|
|:----				|:----			|:----			|:----				|
|取指令码			|CS				|无				|IP					|
|堆栈操作			|SS				|无				|SP					|
|串操作源地址		|DS				|CS ES SS		|SI					|
|串操作目的地址		|ES				|无				|DI					|
|BP 用作基址寄存器	|SS				|CS DS ES		|依寻址方式寻找有效地址|
|一般数据存取		|DS				|CS ES SS		|依寻址方式寻找有效地址|

由上表可知，

1. 当取指令时，代码段的首地址必须存放到 `CS` 寄存器中，不允许使用其他段寄存器取代 `CS`；
2. 访问堆栈时，堆栈段的首地址必须存放到 `SS` 寄存器中，也不允许使用其他段寄存器取代 `SS`；
3. 当执行串操作指令时，源串缺省使用段寄存器 `DS`，也可选用 `CS` `ES` `SS`，而目的串只能使用 `ES` 段寄存器；
4. 当使用 `BP` 作为基址寄存器时，缺省的段寄存器为 `SS`，也可选用 `CS` `DS` `ES`；
5. 而对于一般数据的存取，缺省的段寄存器为 `DS`，也可选用 `CS` `ES` `SS`。

### 2.2.3 指针寄存器和变址寄存器
`指针寄存器` 和 `变址寄存器` 共有 4 个 16 位寄存器，即 

* `SP` -> 堆栈指针寄存器
* `BP` -> 基址指针寄存器
* `SI` -> 源变址寄存器
* `DI` -> 目的变址寄存器

**主要用于在访问存储单元时提供 16 位偏移地址。**

    注意
    指针寄存器和变址寄存器不可分割成 8 位寄存器，只能进行字节访问。

#### SP (Stack Pointer) -> 堆栈指针寄存器
该寄存器主要用于存放`当前堆栈段的段内偏移地址`，即 `顶地址`。

#### BP (Base Pointer) -> 基址指针寄存器
该寄存器常用于提供堆栈内某个单元的偏移地址，与 `SS` 段寄存器联用，可以访问堆栈中的任意一个存储单元。

#### SI (Source Index) -> 源变址寄存器
在串操作指令中，`SI` 作为隐含的源变址寄存器与数据段寄存器 `DS` 联用，以确定数据段中的存储单元地址，然后根
据 `DF` 标志，`SI` 进行自动增量或自动减量。

#### DI (Destination Index) -> 目的变址寄存器
在串操作指令中，`DI` 作为隐含的目的变址寄存器与附加段寄存器 `ES` 联用，以达到在附加段中寻址的目的，然后根
据 `DF` 标志，`DI` 进行自动增量或减量。

### 2.2.4 控制寄存器
控制寄存器共有 2 个 16 位寄存器，即 

* IP
* FR

#### 1. IP 寄存器
IP (Instruction Pointer) : 指令指针寄存器。用来存放代码段中指令的偏移地址。在程序运行的过程中，`IP` 与 `CS` 联用，
以确定下一条指令的物理地址。该寄存器为`专用寄存器`，一般不能用于存储其他数据。

#### 2. FR 寄存器
FR (Flags Register) : 标志寄存器。主要用于`反映处理器的状态`和`运算结果的某些特征`。

标志寄存器包含了 9 个标志， 6 个是 `条件码标志位`，3 个是 `控制标志位`。各标志位在标志寄存器中的位置如下：

    |15|14|13|12|11|10| 9| 8| 7| 6| 5| 4| 3| 2| 1| 0|
	|  |  |  |  |OF|DF|IF|TF|SF|ZF|  |AF|  |PF|  |CF|

标志寄存器的作用：

1. 有些指令的执行会影响标志，而有些指令的执行不会影响标志位；
2. 反过来，有些指令的执行会受标志的影响，而有些指令的执行不会受标志的影响；

因此，程序员要充分注意`指令`与`标志`的关系。

##### (1) 条件标志

###### CF (Carry Flag) -> 进位标志
`CF` 主要用于反映运算是否产生`进位`或`借位`。

* 如果运算结果的最高位（**字操作时的第 15 位，字节操作时的第 7 位**）产生一个进位或借位，则 `CF` 置 1；
* 否则 `CF` 置 0 。

`移位指令`也会把操作数的最高位或最低位移入 `CF` 。移位指令与 `CF` 配合，可实现操作数之间的`位传送`。

###### PF (Parity Flag) -> 奇偶标志
`PF` 用于反映运算结果字节中 "1" 的个数。

* 如果 "1" 的个数为`偶数`，则 `PF` 置 1 ；
* 否则 `PF` 置 0 。

利用 `PF` 可进行奇偶校验检查，或产生奇偶校验位。在串行通信中，为了提高传送的可靠性，常采用奇偶校验。

###### AF (Auxiliary Carry Flag) -> 辅助进位标志
* 在字节操作时，如果发生`低半字节`向`高半字节`进位或借位，则辅助进位标志 `AF` 置 1，否则 `AF` 清 0；
* 在字操作时，如果发生`低字节`向`高字节`进位或借位，则辅助进位标志 `AF` 置 1，否则 `AF` 请 0 。

因此，该标志又被称为 `半进位标志`。

十进制算术运算调整指令会自动根据该标志产生相应的调整动作。

###### ZF (Zero Flag) -> 零标志
`ZF` 用于反映运算结果是否为 0.

    如果运算结果为 0，则 `ZF` 置 1；否则清 0 。

在判断运算结果是否为 0 时，要用到该标志位。

###### SF (Sign Flag) -> 符号标志
`SF` 用于反映运算结果的符号。

    SF 与运算结果的最高位相同，如果运算结果的最高位为 1，则 SF 置为 1；否则清 0 。

在 `8086/8088` 系统中，有符号数采用`补码`的形式表示，所以 `SF` 反映了运算结果的符号。如果运算结果为正，则 `SF` 清 0 ；
否则 `SF` 置 1 。

###### OF (Overflow Flag) -> 溢出标志
`OF` 用于反映有符号数加减运算是否引起溢出。

    如果运算结果超出了 8 位或 16 位有符号数的表示范围，即在字节运算时大于 127 或小于 -128，在字运算时大于 32 767 或
    小于 -32 768 ，则溢出。如果发生溢出，则 OF 置 1 。

##### (2) 控制标志

###### TF (Trap Flag) -> 陷阱标志
`TF` 用于单步方式操作。

    所谓单步方式是指在一条指令执行后，产生一个单步中断，程序暂停执行，这主要用于程序的调试。（这也是调试器的 CPU 支持。）

当 `TF` 位为 1 时，每条指令执行后产生陷阱，由系统控制计算机。

    8086/8088 没有专门设置和清除 TF 标志的指令，要通过其他方式设置或清除 TF。

###### IF (Interrupt Flag) -> 中断标志
`IF` 决定着 CPU 是否响应外部可屏蔽中断请求。

1. 当 `IF` 为 1 时，CPU 能够响应外部的可屏蔽中断请求，允许中断；
2. 当 `IF` 为 0 时，则不响应外部的可屏蔽中断请求。

但此标志的状态，对于外部的 `非屏蔽中断请求` 或 `内部产生的中断` 不起作用。

    8086/8088 提供的专门用于设置中断允许标志 IF 的指令时 STI，专门用于清 IF 的指令是 CLI。

###### DF (Direction Flag) -> 方向标志
`DF` 决定着`串操作指令`执行时有关`指针寄存器`调整方案。

* 当 `DF` 为 1 时，`串操作指令`按递减方式改变有关的存储器指针值，每次操作后使 `SI` 和 `DI` 减量（这样就使串处理从高地址
向低地址方向处理）；
* 当 `DF` 为 0 时，`串操作指令`按递增方式改变有关的存储器指针值，每次操作后使 `SI` 和 `DI` 增量（这样就使串处理从低地址
向高地址方向处理）。

`FR` 寄存器的标志位（`TF` 标志除外）在计算机中表示如下表所列：

|标志位|标志位名称|符号表示||
|:------|:------|:------|:------|
|||=1|=0|
|OF|溢出标志（是/否）|OV|NV|
|DF|方向标志（减/增）|DN|UP|
|IF|中断标志（开/关）|EI|DI|
|SF|符号标志（负/正）|NG|PL|
|ZF|零标志（是/否）|ZR|NZ|
|AF|辅助进位标志（是/否）|AC|NA|
|PF|奇偶标志（偶/奇）|PE|PO|
|CF|进行标志（是/否）|CY|NC|

在调试程序过程中，必须经常观察这些标志位的值。

以上所讲述的各种寄存器以及 `FR` 标志，均可通过 DOS 系统中提供的 DEBUG 调试工具进行查看，查看命令为 `R` - （显示各寄存器
的当前值）。使用`DEBUG`程序中的 `R` 命令查看各种寄存器以及 `FR` 寄存器的各个标志位状态（`TF` 标志除外）。

    Microsoft (R) KKCFUNC ﾊﾞｰｼﾞｮﾝ 1.10
    Copyright (C) Microsoft Corp. 1991,1993. All rights reserved.
    
    KKCFUNC が組み込まれました.
    
    マイクロソフトかな漢字変換  ﾊﾞｰｼﾞｮﾝ 2.51
    (C)Copyright Microsoft Corp. 1992-1993
    -R
    AX=0000  BX=0000  CX=0000  DX=0000  SP=FFEE  BP=0000  SI=0000  DI=0000
    DS=2491  ES=2491  SS=2491  CS=2491  IP=0100   NV UP EI PL NZ NA PO NC (FR 标志位的表示符号)
    2491:0100 93            XCHG    BX,AX
    -

## 2.3 存储器结构与堆栈
存储器是计算机存储信息的主要部件，`程序代码`、`数据`、`程序的运算结果`都保存在存储器中。

    堆栈则是存储器中的一块专用存储区，在操作系统和应用程序中都具有特殊的重要功能。

### 2.3.1 存储器结构
在存储器中，信息是以`字节（8 个二进制位）`为最小存储单位，每一个字节单元分配一个唯一的存储器地址。`8086/8088` CPU 有 
20 根地址线，地址用无符号二进制数表示，但为了方便书写，常用无符号十六进制数（数后加`基数`说明符 `H`）表示。

一个存储单元中存放的信息成为该单元的内容。

          |存储器|
          |      |
    00100H| 27H  |
    00101H| 34H  |
    00102H| 12H  |
    00103H| 68H  |
          |      |

如上图所示，地址是 `00100H` 的字节单元内容为 27H，`00101H` 的字节单元内容为 34H，`00102H` 的字节单元的内容为 12H，
`00103H` 的字节单元的内容为 68H。

    高高低低原则
    一个字数据在存储器中存于相邻的两个字节单元，数据的低字节存入低地址单元，高字节存入高地址单元。

因此，按地址递增方式存储一个数据时，应先存低字节数据，再存高字节数据，这就是通常称为的**“高高低低”**原则，访问
存储器必须遵守该原则，在访问字单元时，一般给出的是字单元的低地址。

例如，在上图中，如果用户要访问地址为 `00100H` 的字单元，则该地址单元所存储的内容为 3427H（低地址为 00100H，高地址
为 00101H）。

要访问一个存储器单元，必须先得到该存储器单元的物理地址。

    物理地址是由段地址和偏移地址合成的。

为什么是段地址和偏移地址呢？

这是由于 `8086/8088` 用于寻址的寄存器都是 16 位（如 `BX` `BP` 等）的，而 16 位的寄存器只能寻址 `64 KB` 的地址范围；
但 `8086/8088` CPU 具有 `20` 根地址线，寻址可达 `1 MB` 地址范围，即 `00000H ~ 0FFFFFH` 范围内的地址。为了能在 16 位
字长的寄存器中提供 20 位地址线，`8086/8088` 采用了存储器分段管理方法。

在介绍存储器分段管理方法之前，先介绍描述存储器地址的 4 个相关术语：

* 物理地址（PA）
* 段首址（SB）
* 偏移地址（EA）
* 逻辑地址（LA）

#### 物理地址（Physical Address）
是由 `8086/8088` 的地址线送出的 20 位地址码。如果 `8086/8088` CPU 要访问存储器任意的一个单元，则必须提供一个 20 位的
二进制数给`地址总线`，才能访问该存储单元。

#### 段首址（Segment Base）
是存储器中每一段的起始地址，又称为`段基址`。

#### 偏移地址（Effective Address）
是相对于`某段首地址`的`段内偏移量`，用 16 位二进制代码表示，写成 4 位十六进制数。

#### 逻辑地址（Logic Address）
是在程序中对存储器地址的一种表示方法，由某段的`段首址`和`段内偏移地址`组成。一般写成：

    段首址：偏移地址

如

    0B47H:0080H

存储器地址分段的具体做法是：

    从 0 地址开始，把 1MB 的存储器空间分成若干段，每 16 字节为一小段，段的起始地址必须是从任一小段的首地址开始；
    也就是说，当一个段开始的物理地址表示成 20 位的二进制地址码时，其最低 4 位是 0 。

每段的最小容量为 `16 B`，最大容量为 `64 KB`。这样，段内地址就可以用 16 位来表示。实际上，可以根据编程的需要来确定
段的大小。它可以是 `64 KB` 范围内的任意多个字节。

存储器采用分段管理后，每个段的首地址（称为`段基地址`或`段地址`）保存在 `8086/8088` 内部的 `CS` `DS` `ES` `SS` 这 4 
个 16 位寄存器中，可以对段寄存器设置不同的值，以指向不同的段。

##### 实模式
16 位的段地址和 16 位的偏移地址组合形成 20 位的物理地址，这就是 `8086/8088` 存储器分段的工作方式，这在 `8086/8088` 的
寻址模式中称为 `实模式`。

##### 8086/8088 存储器物理地址的计算方式
把段首址左移 4 位再加上偏移地址就形成物理地址。

    物理地址 = 段首址 * 16D + 偏移地址

##### 例 2-1 
设有以下 4 组逻辑地址，求它们的物理地址。

1. 0ABCDH:0234H
2. 0FFF0H:00FFH
3. 1234H:0000H
4. 1230H:0040H

**解:** 如果知道`逻辑地址`，则根据公式 ` 物理地址 = 段首址 * 16D + 偏移地址` 可求其对应的物理地址。

① 物理地址 = ABCDH * 16D + 0234H = ABCD0H + 0234H = ABF04H

② 物理地址 = FFF0H * 16D + 00FFH = FFF00H + 00FFH = FFFFFH

③ 物理地址 = 1234H * 16D + 0000H = 12340H + 0000H = 12340H

④ 物理地址 = 1230H * 16D + 0040H = 12300H + 0040H = 12340H

由例可知第③、④小题可知，逻辑地址为 `1234H:0000H` 和逻辑地址为 `1230H:0040H` 所求得的物理地址均为 `12340H`。
即 `8086/8088` `1 MB` 的存储器其每个存储单元的物理地址是唯一的，但是与它对应的逻辑地址可以有很多。

    按照分段方法不难知道，8086/8088 存储器 1 MB 地址空间
    1. 最多可以分为 64 K 个段，每个段均为 16 字节；
    2. 最少可分为 16 个段，每个段均为 64 KB。

### 2.3.2 堆栈
`堆栈`是系统存储器中开辟出的一块特殊区域，用于`保存断点地址`及`需要保存的数据`。其数据的存取原则是 `先进后出`。

堆栈的`固定端`称为`栈底`，`活动端`称为栈顶，数据的存取都是在栈顶进行，堆栈栈顶指针寄存器 `SP` 始终存放栈顶单元的地址，
即 `SP` 始终执行栈顶，跟踪栈顶的变化。

`8086/8088`指令系统有两条堆栈指令（`PUSH` `POP`）专门完成数据的入栈和出栈，具体操作过程将在第 3 章进行详解。

**入栈**

    低地址     |          | 
               |          | 
     ↑         |          | 
    SP →       |  栈顶    | 
               |          | 
               |          | 
               |          | 
               |          | 
               |          | 
               |          | 
    高地址     |  栈底    | 

**出栈**

    低地址     |          | 
               |          | 
               |          | 
    SP →       |  栈顶    | 
     ↓         |          | 
               |          | 
               |          | 
               |          | 
               |          | 
               |          | 
    高地址     |  栈底    | 

**注意**

    堆栈存取必须以字为单位，每次操作后，SP 总是指向新的栈顶。随着数据入栈的增多，堆栈区域将不断扩展，SP 的值不断减小，堆栈的
    栈顶从高地址向低地址方向扩展；随着数据的不断出栈，堆栈区域又将不断缩小，SP 的值不断增大，堆栈栈顶从低地址向高地址方向扩展。

## 2.4 汇编语言程序的调试
一般来说，要完成汇编语言的上机调试，需要用到 `EDIT` 编辑软件、`MASM` 汇编程序、`LINK` 链接程序和 `DEBUG` 调试程序。

### 2.4.1 汇编语言程序
汇编语言程序是由程序员按照汇编语言的各种书写要求编写而成的程序，所以它又被称为 `汇编语言源程序`。如果要将编写好的汇编语言源程序
输入计算机并保存，则一般使用 `EDIT` 编辑程序。汇编语言程序以文件的形式保存到计算机中，该文件的扩展名为 `.ASM`，而主文件名任意。

下面先简单介绍段的定义及概念。

汇编语言程序主要由 4 种基本段组成：

* 代码段
* 数据段
* 堆栈段
* 附加段

其中`代码段`是一个汇编语言程序所必须具备的段，其他段可有可无。即一个代码段就可以构成一个最简单的汇编语言程序。

#### 1. 代码段
代码段是由汇编指令组成的程序段，其各条指令组合起来可完成预定的任务。代码段的首地址由 `CS` 段寄存器指向，偏移量由 `IP` 寄存器指向。

代码段的格式如下：

    段名          SEGMENT
                  .
                  .
                  .
    段名          ENDS

汇编语言规定，每个段都要给出一个段名，作为这个段的名称，并且该段名可以代表该段所在内存的段地址。

段名称的命名规则为：

    采用字母（A~Z a~z）、数字（0~9）、以及专用字符（"?"、"."、"@"、"-"、"$"）组成的字符串。注意，段名不能与系统保留字同名。

段开始语句的定义符是 `SEGMENT` ，段结束语句的定义符是 `ENDS`，两者配合使用。另外，段开始的段名和段结束的段名必须相同。

##### 例 2-2 代码段的定义举例

    CSEG SEGMENT
    	ASSUME CS:CSEG
    START:
    	MOV AX, 1234H				; AX <- 1234H
    	MOV BX, 5678H				; BX <- 5678H
    		.
    		.
    		.
    	MOV AH, 4CH
    	INT 21H						; 返回 DOS
    CSEG ENDS
    END START

该例题给出了一个代码段的定义，该代码段的名称为 CSEG。