# 第 2 章 8086/8088 CPU 的内部结构与汇编语言程序上机
本章主要内容：

1. 介绍 `8086/8088` CPU 的内部结构；
2. 阐述 `8086/8088` CPU 内部各个寄存器的功能及用途；
3. 讲解 `8086/8088` CPU 的存储器结构。

最后简单介绍了汇编语言程序设计的基本方法，并给出两个汇编语言程序实例。

## 2.1 8086/8088 CPU 的功能结构
`中央处理器 CPU 的任务是执行存放在存储器里的指令序列。` CPU 一般由 `运算器` 和 `控制器` 两部分组成，在微机中也常称为
`微处理器`。

`8086/8088` CPU 按功能可分为两个独立的部件：

* 总线接口单元 BIU (Bus Interface Unit)
* 执行单元 EU (Execution Unit)

### BIU
`BIU` 单元负责完成 

1. `8086/8088` CPU 与存储器之间的信息传送；
2. 总线控制；
3. I/O 数据传送；
4. 逻辑地址与物理地址转换；
5. 从存储器中取指令送至指令流队列排队；
6. 取出执行指令时所需的操作数，并传送给 `EU` 单元完成运算和操作。

### EU
`EU` 单元负责对来自指令流队列中的指令译码并执行，实施算术逻辑运算操作。

### 指令流水线
由于 `BIU` 和 `EU` 是两个相对独立的部件，因此取指令和执行指令可以并行完成，形成指令流水线结构。

指令流结构大大减少了 CPU 等待取指令的时间，提高了 CPU 的利用率和系统运行速度。

## 2.2 8086/8088 的寄存器结构
`8086/8088` CPU 共有 **14** 个 **16** 位寄存器，一般分为 4 类：

1. 数据寄存器；
2. 段寄存器；
3. 控制寄存器；
4. 指针寄存器。

具体分类如下：

    8086/8088 寄存器
      ├─通用寄存器
      │  ├─数据寄存器
      │  │  ├─AX -> |AH|AL|
      │  │  ├─BX -> |BH|BL|
      │  │  ├─CX -> |CH|CL|
      │  │  └─DX -> |DH|DL|
      │  ├─指针寄存器
      │  │  ├─堆栈指针寄存器
      │  │  │  └─SP
      │  │  └─基址变址寄存器
      │  │     └─BP
      │  └─变址寄存器
      │     ├─源变址寄存器
      │     │  └─SI
      │     └─目的变址寄存器
      │        └─DI
      ├─控制寄存器
      │  ├─指令指针寄存器
      │  │  └─IP
      │  └─标志寄存器
      │  	  └─FR
      └─段寄存器
          ├─代码段寄存器
          │  └─CS
          ├─数据段寄存器
          │  └─DS
          ├─附加段寄存器
          │  └─ES
          └─堆栈段寄存器
             └─SS

这些寄存器具有重要的作用，专门用于存放指令执行时需要的各种信息，如

* 操作数；
* 操作数地址；
* 中间计算结果。

### 2.2.1 数据寄存器 （Data Segment Register -> DS）
数据寄存器共有 4 个 16 位寄存器，即 `AX` `BX` `CX` `DX`，通常用来暂存计算过程中的操作数、运算结果或其他信息。它们既可以
作为一个 16 位的寄存器使用，也可以作为两个 8 位的寄存器分开使用。当它们作为两个 8 位寄存器用时，按高低字节分。

高 8 位寄存器命名为

* AH
* BH
* CH
* DH

低 8 位寄存器命名为

* AL
* BL
* CL
* DL

数据寄存器除了上述用途外，还有各自的专门用途。

#### AX (Accumulator) -> 累加器
它是算术运算的主要寄存器。此外还可以作为

* 乘法运算
* 除法运算
* 输入/输出指令的专用寄存器

#### BX (Base) -> 基址寄存器
该寄存器常用于存放存储区的起始地址。

#### CX (Count) -> 计数寄存器
该寄存器常用于循环操作或字符串操作过程中的计数。

#### DX (Data) 
该寄存器常与 `AX` 配合，用于双字长运算，`DX` 存放高位字，`AX` 存放低位字。此外，还可用于输入/输出指令中存放外部设备
接口的端口地址。

* [x86 memory segmentation -> DS](http://en.wikipedia.org/wiki/X86_memory_segmentation)
* [X86 Assembly/X86 Architecture](http://en.wikibooks.org/wiki/X86_Assembly/X86_Architecture)
* [Memory data register](http://en.wikipedia.org/wiki/Memory_data_register)

### 2.2.2 段寄存器 -> (Segment Register)
为了运用所有的内存空间，`8086/8088` CPU 设定了 4 个段寄存器，分别为：

* CS
* DS
* ES
* SS

专门用于保存段首地址。

#### CS (Code Segment) -> 代码段寄存器
该寄存器用于存放正在或者正待执行的程序的段首址，其值为代码段的段值。

#### DS (Data Segment) -> 数据段寄存器
该寄存器用于存放正在或正待执行的数据段的段首址，其值为数据段的段值。

#### ES (Extra Segment) -> 附加段寄存器
该寄存器用于存放正在或正待执行的附加段的段首址，其值为附加数据段的段值。

#### SS (Stack Segment) -> 堆栈段寄存器
该寄存器用于存放正在或正待执行的堆栈段的段首址，其值为堆栈段的段值。

通常情况下

1. `CS` 划定并控制当前程序区；
2. `DS` 和 `ES` 划定并控制数据区；
3. `SS` 划定并控制堆栈区；

#### 段寄存器使用约定
|访问存储区类型    	|缺省段寄存器	|可指定段寄存器	|段内偏移地址来源	|
|:----				|:----			|:----			|:----				|
|取指令码			|CS				|无				|IP					|
|堆栈操作			|SS				|无				|SP					|
|串操作源地址		|DS				|CS ES SS		|SI					|
|串操作目的地址		|ES				|无				|DI					|
|BP 用作基址寄存器	|SS				|CS DS ES		|依寻址方式寻找有效地址|
|一般数据存取		|DS				|CS ES SS		|依寻址方式寻找有效地址|

由上表可知，

1. 当取指令时，代码段的首地址必须存放到 `CS` 寄存器中，不允许使用其他段寄存器取代 `CS`；
2. 访问堆栈时，堆栈段的首地址必须存放到 `SS` 寄存器中，也不允许使用其他段寄存器取代 `SS`；
3. 当执行串操作指令时，源串缺省使用段寄存器 `DS`，也可选用 `CS` `ES` `SS`，而目的串只能使用 `ES` 段寄存器；
4. 当使用 `BP` 作为基址寄存器时，缺省的段寄存器为 `SS`，也可选用 `CS` `DS` `ES`；
5. 而对于一般数据的存取，缺省的段寄存器为 `DS`，也可选用 `CS` `ES` `SS`。

### 2.2.3 指针寄存器和变址寄存器
`指针寄存器` 和 `变址寄存器` 共有 4 个 16 位寄存器，即 

* `SP` -> 堆栈指针寄存器
* `BP` -> 基址指针寄存器
* `SI` -> 源变址寄存器
* `DI` -> 目的变址寄存器

**主要用于在访问存储单元时提供 16 位偏移地址。**

    注意
    指针寄存器和变址寄存器不可分割成 8 位寄存器，只能进行字节访问。

#### SP (Stack Pointer) -> 堆栈指针寄存器
该寄存器主要用于存放`当前堆栈段的段内偏移地址`，即 `顶地址`。

#### BP (Base Pointer) -> 基址指针寄存器
该寄存器常用于提供堆栈内某个单元的偏移地址，与 `SS` 段寄存器联用，可以访问堆栈中的任意一个存储单元。

#### SI (Source Index) -> 源变址寄存器
在串操作指令中，`SI` 作为隐含的源变址寄存器与数据段寄存器 `DS` 联用，以确定数据段中的存储单元地址，然后根
据 `DF` 标志，`SI` 进行自动增量或自动减量。

#### DI (Destination Index) -> 目的变址寄存器
在串操作指令中，`DI` 作为隐含的目的变址寄存器与附加段寄存器 `ES` 联用，以达到在附加段中寻址的目的，然后根
据 `DF` 标志，`DI` 进行自动增量或减量。

### 2.2.4 控制寄存器
控制寄存器共有 2 个 16 位寄存器，即 

* IP
* FR

#### 1. IP 寄存器
IP (Instruction Pointer) : 指令指针寄存器。用来存放代码段中指令的偏移地址。在程序运行的过程中，`IP` 与 `CS` 联用，
以确定下一条指令的物理地址。该寄存器为`专用寄存器`，一般不能用于存储其他数据。

#### 2. FR 寄存器
FR (Flags Register) : 标志寄存器。主要用于`反映处理器的状态`和`运算结果的某些特征`。

标志寄存器包含了 9 个标志， 6 个是 `条件码标志位`，3 个是 `控制标志位`。各标志位在标志寄存器中的位置如下：

    |15|14|13|12|11|10| 9| 8| 7| 6| 5| 4| 3| 2| 1| 0|
	|  |  |  |  |OF|DF|IF|TF|SF|ZF|  |AF|  |PF|  |CF|

标志寄存器的作用：

1. 有些指令的执行会影响标志，而有些指令的执行不会影响标志位；
2. 反过来，有些指令的执行会受标志的影响，而有些指令的执行不会受标志的影响；

因此，程序员要充分注意`指令`与`标志`的关系。

##### (1) 条件标志

###### CF (Carry Flag) -> 进位标志
`CF` 主要用于反映运算是否产生`进位`或`借位`。

* 如果运算结果的最高位（**字操作时的第 15 位，字节操作时的第 7 位**）产生一个进位或借位，则 `CF` 置 1；
* 否则 `CF` 置 0 。

`移位指令`也会把操作数的最高位或最低位移入 `CF` 。移位指令与 `CF` 配合，可实现操作数之间的`位传送`。

###### PF (Parity Flag) -> 奇偶标志
`PF` 用于反映运算结果字节中 "1" 的个数。

* 如果 "1" 的个数为`偶数`，则 `PF` 置 1 ；
* 否则 `PF` 置 0 。

利用 `PF` 可进行奇偶校验检查，或产生奇偶校验位。在串行通信中，为了提高传送的可靠性，常采用奇偶校验。

###### AF (Auxiliary Carry Flag) -> 辅助进位标志
* 在字节操作时，如果发生`低半字节`向`高半字节`进位或借位，则辅助进位标志 `AF` 置 1，否则 `AF` 清 0；
* 在字操作时，如果发生`低字节`向`高字节`进位或借位，则辅助进位标志 `AF` 置 1，否则 `AF` 请 0 。

因此，该标志又被称为 `半进位标志`。

十进制算术运算调整指令会自动根据该标志产生相应的调整动作。

###### ZF (Zero Flag) -> 零标志
`ZF` 用于反映运算结果是否为 0.

    如果运算结果为 0，则 `ZF` 置 1；否则清 0 。

在判断运算结果是否为 0 时，要用到该标志位。

###### SF (Sign Flag) -> 符号标志
`SF` 用于反映运算结果的符号。

    SF 与运算结果的最高位相同，如果运算结果的最高位为 1，则 SF 置为 1；否则清 0 。

在 `8086/8088` 系统中，有符号数采用`补码`的形式表示，所以 `SF` 反映了运算结果的符号。如果运算结果为正，则 `SF` 清 0 ；
否则 `SF` 置 1 。

###### OF (Overflow Flag) -> 溢出标志
`OF` 用于反映有符号数加减运算是否引起溢出。

    如果运算结果超出了 8 位或 16 位有符号数的表示范围，即在字节运算时大于 127 或小于 -128，在字运算时大于 32 767 或
    小于 -32 768 ，则溢出。如果发生溢出，则 OF 置 1 。

##### (2) 控制标志

###### TF (Trap Flag) -> 陷阱标志
`TF` 用于单步方式操作。

    所谓单步方式是指在一条指令执行后，产生一个单步中断，程序暂停执行，这主要用于程序的调试。（这也是调试器的 CPU 支持。）

当 `TF` 位为 1 时，每条指令执行后产生陷阱，由系统控制计算机。

    8086/8088 没有专门设置和清除 TF 标志的指令，要通过其他方式设置或清除 TF。

###### IF (Interrupt Flag) -> 中断标志
`IF` 决定着 CPU 是否响应外部可屏蔽中断请求。

1. 当 `IF` 为 1 时，CPU 能够响应外部的可屏蔽中断请求，允许中断；
2. 当 `IF` 为 0 时，则不响应外部的可屏蔽中断请求。

但此标志的状态，对于外部的 `非屏蔽中断请求` 或 `内部产生的中断` 不起作用。

    8086/8088 提供的专门用于设置中断允许标志 IF 的指令时 STI，专门用于清 IF 的指令是 CLI。

###### DF (Direction Flag) -> 方向标志
`DF` 决定着`串操作指令`执行时有关`指针寄存器`调整方案。

* 当 `DF` 为 1 时，`串操作指令`按递减方式改变有关的存储器指针值，每次操作后使 `SI` 和 `DI` 减量（这样就使串处理从高地址
向低地址方向处理）；
* 当 `DF` 为 0 时，`串操作指令`按递增方式改变有关的存储器指针值，每次操作后使 `SI` 和 `DI` 增量（这样就使串处理从低地址
向高地址方向处理）。

`FR` 寄存器的标志位（`TF` 标志除外）在计算机中表示如下表所列：

|标志位|标志位名称|符号表示||
|:------|:------|:------|:------|
|||=1|=0|
|OF|溢出标志（是/否）|OV|NV|
|DF|方向标志（减/增）|DN|UP|
|IF|中断标志（开/关）|EI|DI|
|SF|符号标志（负/正）|NG|PL|
|ZF|零标志（是/否）|ZR|NZ|
|AF|辅助进位标志（是/否）|AC|NA|
|PF|奇偶标志（偶/奇）|PE|PO|
|CF|进行标志（是/否）|CY|NC|

在调试程序过程中，必须经常观察这些标志位的值。

以上所讲述的各种寄存器以及 `FR` 标志，均可通过 DOS 系统中提供的 DEBUG 调试工具进行查看，查看命令为 `R` - （显示各寄存器
的当前值）。使用`DEBUG`程序中的 `R` 命令查看各种寄存器以及 `FR` 寄存器的各个标志位状态（`TF` 标志除外）。

    Microsoft (R) KKCFUNC ﾊﾞｰｼﾞｮﾝ 1.10
    Copyright (C) Microsoft Corp. 1991,1993. All rights reserved.
    
    KKCFUNC が組み込まれました.
    
    マイクロソフトかな漢字変換  ﾊﾞｰｼﾞｮﾝ 2.51
    (C)Copyright Microsoft Corp. 1992-1993
    -R
    AX=0000  BX=0000  CX=0000  DX=0000  SP=FFEE  BP=0000  SI=0000  DI=0000
    DS=2491  ES=2491  SS=2491  CS=2491  IP=0100   NV UP EI PL NZ NA PO NC (FR 标志位的表示符号)
    2491:0100 93            XCHG    BX,AX
    -

## 2.3 存储器结构与堆栈
存储器是计算机存储信息的主要部件，`程序代码`、`数据`、`程序的运算结果`都保存在存储器中。

    堆栈则是存储器中的一块专用存储区，在操作系统和应用程序中都具有特殊的重要功能。




