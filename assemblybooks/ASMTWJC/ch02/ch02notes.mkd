# 第 2 章 8086/8088 CPU 的内部结构与汇编语言程序上机
本章主要内容：

1. 介绍 `8086/8088` CPU 的内部结构；
2. 阐述 `8086/8088` CPU 内部各个寄存器的功能及用途；
3. 讲解 `8086/8088` CPU 的存储器结构。

最后简单介绍了汇编语言程序设计的基本方法，并给出两个汇编语言程序实例。

## 2.1 8086/8088 CPU 的功能结构
`中央处理器 CPU 的任务是执行存放在存储器里的指令序列。` CPU 一般由 `运算器` 和 `控制器` 两部分组成，在微机中也常称为
`微处理器`。

`8086/8088` CPU 按功能可分为两个独立的部件：

* 总线接口单元 BIU (Bus Interface Unit)
* 执行单元 EU (Execution Unit)

### BIU
`BIU` 单元负责完成 

1. `8086/8088` CPU 与存储器之间的信息传送；
2. 总线控制；
3. I/O 数据传送；
4. 逻辑地址与物理地址转换；
5. 从存储器中取指令送至指令流队列排队；
6. 取出执行指令时所需的操作数，并传送给 `EU` 单元完成运算和操作。

### EU
`EU` 单元负责对来自指令流队列中的指令译码并执行，实施算术逻辑运算操作。

### 指令流水线
由于 `BIU` 和 `EU` 是两个相对独立的部件，因此取指令和执行指令可以并行完成，形成指令流水线结构。

指令流结构大大减少了 CPU 等待取指令的时间，提高了 CPU 的利用率和系统运行速度。

## 2.2 8086/8088 的寄存器结构
`8086/8088` CPU 共有 **14** 个 **16** 位寄存器，一般分为 4 类：

1. 数据寄存器；
2. 段寄存器；
3. 控制寄存器；
4. 指针寄存器。

具体分类如下：

    8086/8088 寄存器
      ├─通用寄存器
      │  ├─数据寄存器
      │  │  ├─AX -> |AH|AL|
      │  │  ├─BX -> |BH|BL|
      │  │  ├─CX -> |CH|CL|
      │  │  └─DX -> |DH|DL|
      │  ├─指针寄存器
      │  │  ├─堆栈指针寄存器
      │  │  │  └─SP
      │  │  └─基址变址寄存器
      │  │     └─BP
      │  └─变址寄存器
      │     ├─源变址寄存器
      │     │  └─SI
      │     └─目的变址寄存器
      │        └─DI
      ├─控制寄存器
      │  ├─指令指针寄存器
      │  │  └─IP
      │  └─标志寄存器
      │  	  └─FR
      └─段寄存器
          ├─代码段寄存器
          │  └─CS
          ├─数据段寄存器
          │  └─DS
          ├─附加段寄存器
          │  └─ES
          └─堆栈段寄存器
             └─SS

这些寄存器具有重要的作用，专门用于存放指令执行时需要的各种信息，如

* 操作数；
* 操作数地址；
* 中间计算结果。

### 2.2.1 数据寄存器 （Data Segment Register -> DS）
数据寄存器共有 4 个 16 位寄存器，即 `AX` `BX` `CX` `DX`，通常用来暂存计算过程中的操作数、运算结果或其他信息。它们既可以
作为一个 16 位的寄存器使用，也可以作为两个 8 位的寄存器分开使用。当它们作为两个 8 位寄存器用时，按高低字节分。

高 8 位寄存器命名为

* AH
* BH
* CH
* DH

低 8 位寄存器命名为

* AL
* BL
* CL
* DL

数据寄存器除了上述用途外，还有各自的专门用途。

#### AX (Accumulator) -> 累加器
它是算术运算的主要寄存器。此外还可以作为

* 乘法运算
* 除法运算
* 输入/输出指令的专用寄存器

#### BX (Base) -> 基址寄存器
该寄存器常用于存放存储区的起始地址。

#### CX (Count) -> 计数寄存器
该寄存器常用于循环操作或字符串操作过程中的计数。

#### DX (Data) 
该寄存器常与 `AX` 配合，用于双字长运算，`DX` 存放高位字，`AX` 存放低位字。此外，还可用于输入/输出指令中存放外部设备
接口的端口地址。

* [x86 memory segmentation -> DS](http://en.wikipedia.org/wiki/X86_memory_segmentation)
* [X86 Assembly/X86 Architecture](http://en.wikibooks.org/wiki/X86_Assembly/X86_Architecture)
* [Memory data register](http://en.wikipedia.org/wiki/Memory_data_register)

### 2.2.2 段寄存器 -> (Segment Register)
为了运用所有的内存空间，`8086/8088` CPU 设定了 4 个段寄存器，分别为：

* CS
* DS
* ES
* SS

专门用于保存段首地址。

#### CS (Code Segment) -> 代码段寄存器
该寄存器用于存放正在或者正待执行的程序的段首址，其值为代码段的段值。

#### DS (Data Segment) -> 数据段寄存器
该寄存器用于存放正在或正待执行的数据段的段首址，其值为数据段的段值。

#### ES (Extra Segment) -> 附加段寄存器
该寄存器用于存放正在或正待执行的附加段的段首址，其值为附加数据段的段值。

#### SS (Stack Segment) -> 堆栈段寄存器
该寄存器用于存放正在或正待执行的堆栈段的段首址，其值为堆栈段的段值。

通常情况下

1. `CS` 划定并控制当前程序区；
2. `DS` 和 `ES` 划定并控制数据区；
3. `SS` 划定并控制堆栈区；

#### 段寄存器使用约定
|访问存储区类型    	|缺省段寄存器	|可指定段寄存器	|段内偏移地址来源	|
|:----				|:----			|:----			|:----				|
|取指令码			|CS				|无				|IP					|
|堆栈操作			|SS				|无				|SP					|
|串操作源地址		|DS				|CS ES SS		|SI					|
|串操作目的地址		|ES				|无				|DI					|
|BP 用作基址寄存器	|SS				|CS DS ES		|依寻址方式寻找有效地址|
|一般数据存取		|DS				|CS ES SS		|依寻址方式寻找有效地址|

由上表可知，

1. 当取指令时，代码段的首地址必须存放到 `CS` 寄存器中，不允许使用其他段寄存器取代 `CS`；
2. 访问堆栈时，堆栈段的首地址必须存放到 `SS` 寄存器中，也不允许使用其他段寄存器取代 `SS`；
3. 当执行串操作指令时，源串缺省使用段寄存器 `DS`，也可选用 `CS` `ES` `SS`，而目的串只能使用 `ES` 段寄存器；
4. 当使用 `BP` 作为基址寄存器时，缺省的段寄存器为 `SS`，也可选用 `CS` `DS` `ES`；
5. 而对于一般数据的存取，缺省的段寄存器为 `DS`，也可选用 `CS` `ES` `SS`。

### 2.2.3 指针寄存器和变址寄存器
`指针寄存器` 和 `变址寄存器` 共有 4 个 16 位寄存器，即 

* `SP` -> 堆栈指针寄存器
* `BP` -> 基址指针寄存器
* `SI` -> 源变址寄存器
* `DI` -> 目的变址寄存器

**主要用于在访问存储单元时提供 16 位偏移地址。**

    注意
    指针寄存器和变址寄存器不可分割成 8 位寄存器，只能进行字节访问。

#### SP (Stack Pointer) -> 堆栈指针寄存器
该寄存器主要用于存放`当前堆栈段的段内偏移地址`，即 `顶地址`。

#### BP (Base Pointer) -> 基址指针寄存器
该寄存器常用于提供堆栈内某个单元的偏移地址，与 `SS` 段寄存器联用，可以访问堆栈中的任意一个存储单元。

#### SI (Source Index) -> 源变址寄存器
在串操作指令中，`SI` 作为隐含的源变址寄存器与数据段寄存器 `DS` 联用，以确定数据段中的存储单元地址，然后根
据 `DF` 标志，`SI` 进行自动增量或自动减量。

#### DI (Destination Index) -> 目的变址寄存器
在串操作指令中，`DI` 作为隐含的目的变址寄存器与附加段寄存器 `ES` 联用，以达到在附加段中寻址的目的，然后根
据 `DF` 标志，`DI` 进行自动增量或减量。

### 2.2.4 控制寄存器
控制寄存器共有 2 个 16 位寄存器，即 

* IP
* FR

#### 1. IP 寄存器
IP (Instruction Pointer) : 指令指针寄存器。用来存放代码段中指令的偏移地址。在程序运行的过程中，`IP` 与 `CS` 联用，
以确定下一条指令的物理地址。该寄存器为`专用寄存器`，一般不能用于存储其他数据。

#### 2. FR 寄存器
FR (Flags Register) : 标志寄存器。主要用于`反映处理器的状态`和`运算结果的某些特征`。

标志寄存器包含了 9 个标志， 6 个是 `条件码标志位`，3 个是 `控制标志位`。各标志位在标志寄存器中的位置如下：

    |15|14|13|12|11|10| 9| 8| 7| 6| 5| 4| 3| 2| 1| 0|
	|  |  |  |  |OF|DF|IF|TF|SF|ZF|  |AF|  |PF|  |CF|

标志寄存器的作用：

1. 有些指令的执行会影响标志，而有些指令的执行不会影响标志位；
2. 反过来，有些指令的执行会受标志的影响，而有些指令的执行不会受标志的影响；

因此，程序员要充分注意`指令`与`标志`的关系。

##### (1) 条件标志

###### CF (Carry Flag) -> 进位标志
`CF` 主要用于反映运算是否产生`进位`或`借位`。

* 如果运算结果的最高位（**字操作时的第 15 位，字节操作时的第 7 位**）产生一个进位或借位，则 `CF` 置 1；
* 否则 `CF` 置 0 。

`移位指令`也会把操作数的最高位或最低位移入 `CF` 。移位指令与 `CF` 配合，可实现操作数之间的`位传送`。

###### PF (Parity Flag) -> 奇偶标志
`PF` 用于反映运算结果字节中 "1" 的个数。

* 如果 "1" 的个数为`偶数`，则 `PF` 置 1 ；
* 否则 `PF` 置 0 。

利用 `PF` 可进行奇偶校验检查，或产生奇偶校验位。在串行通信中，为了提高传送的可靠性，常采用奇偶校验。

###### AF (Auxiliary Carry Flag) -> 辅助进位标志
* 在字节操作时，如果发生`低半字节`向`高半字节`进位或借位，则辅助进位标志 `AF` 置 1，否则 `AF` 清 0；
* 在字操作时，如果发生`低字节`向`高字节`进位或借位，则辅助进位标志 `AF` 置 1，否则 `AF` 请 0 。

因此，该标志又被称为 `半进位标志`。

十进制算术运算调整指令会自动根据该标志产生相应的调整动作。

###### ZF (Zero Flag) -> 零标志
`ZF` 用于反映运算结果是否为 0.

    如果运算结果为 0，则 `ZF` 置 1；否则清 0 。

在判断运算结果是否为 0 时，要用到该标志位。

###### SF (Sign Flag) -> 符号标志
`SF` 用于反映运算结果的符号。

    SF 与运算结果的最高位相同，如果运算结果的最高位为 1，则 SF 置为 1；否则清 0 。

在 `8086/8088` 系统中，有符号数采用`补码`的形式表示，所以 `SF` 反映了运算结果的符号。如果运算结果为正，则 `SF` 清 0 ；
否则 `SF` 置 1 。

###### OF (Overflow Flag) -> 溢出标志
`OF` 用于反映有符号数加减运算是否引起溢出。

    如果运算结果超出了 8 位或 16 位有符号数的表示范围，即在字节运算时大于 127 或小于 -128，在字运算时大于 32 767 或
    小于 -32 768 ，则溢出。如果发生溢出，则 OF 置 1 。

##### (2) 控制标志

###### TF (Trap Flag) -> 陷阱标志
`TF` 用于单步方式操作。

    所谓单步方式是指在一条指令执行后，产生一个单步中断，程序暂停执行，这主要用于程序的调试。（这也是调试器的 CPU 支持。）

当 `TF` 位为 1 时，每条指令执行后产生陷阱，由系统控制计算机。

    8086/8088 没有专门设置和清除 TF 标志的指令，要通过其他方式设置或清除 TF。

###### IF (Interrupt Flag) -> 中断标志
`IF` 决定着 CPU 是否响应外部可屏蔽中断请求。

1. 当 `IF` 为 1 时，CPU 能够响应外部的可屏蔽中断请求，允许中断；
2. 当 `IF` 为 0 时，则不响应外部的可屏蔽中断请求。

但此标志的状态，对于外部的 `非屏蔽中断请求` 或 `内部产生的中断` 不起作用。

    8086/8088 提供的专门用于设置中断允许标志 IF 的指令时 STI，专门用于清 IF 的指令是 CLI。

###### DF (Direction Flag) -> 方向标志
`DF` 决定着`串操作指令`执行时有关`指针寄存器`调整方案。

* 当 `DF` 为 1 时，`串操作指令`按递减方式改变有关的存储器指针值，每次操作后使 `SI` 和 `DI` 减量（这样就使串处理从高地址
向低地址方向处理）；
* 当 `DF` 为 0 时，`串操作指令`按递增方式改变有关的存储器指针值，每次操作后使 `SI` 和 `DI` 增量（这样就使串处理从低地址
向高地址方向处理）。

`FR` 寄存器的标志位（`TF` 标志除外）在计算机中表示如下表所列：

|标志位|标志位名称|符号表示||
|:------|:------|:------|:------|
|||=1|=0|
|OF|溢出标志（是/否）|OV|NV|
|DF|方向标志（减/增）|DN|UP|
|IF|中断标志（开/关）|EI|DI|
|SF|符号标志（负/正）|NG|PL|
|ZF|零标志（是/否）|ZR|NZ|
|AF|辅助进位标志（是/否）|AC|NA|
|PF|奇偶标志（偶/奇）|PE|PO|
|CF|进行标志（是/否）|CY|NC|

在调试程序过程中，必须经常观察这些标志位的值。

以上所讲述的各种寄存器以及 `FR` 标志，均可通过 DOS 系统中提供的 DEBUG 调试工具进行查看，查看命令为 `R` - （显示各寄存器
的当前值）。使用`DEBUG`程序中的 `R` 命令查看各种寄存器以及 `FR` 寄存器的各个标志位状态（`TF` 标志除外）。

    Microsoft (R) KKCFUNC ﾊﾞｰｼﾞｮﾝ 1.10
    Copyright (C) Microsoft Corp. 1991,1993. All rights reserved.
    
    KKCFUNC が組み込まれました.
    
    マイクロソフトかな漢字変換  ﾊﾞｰｼﾞｮﾝ 2.51
    (C)Copyright Microsoft Corp. 1992-1993
    -R
    AX=0000  BX=0000  CX=0000  DX=0000  SP=FFEE  BP=0000  SI=0000  DI=0000
    DS=2491  ES=2491  SS=2491  CS=2491  IP=0100   NV UP EI PL NZ NA PO NC (FR 标志位的表示符号)
    2491:0100 93            XCHG    BX,AX
    -

## 2.3 存储器结构与堆栈
存储器是计算机存储信息的主要部件，`程序代码`、`数据`、`程序的运算结果`都保存在存储器中。

    堆栈则是存储器中的一块专用存储区，在操作系统和应用程序中都具有特殊的重要功能。

### 2.3.1 存储器结构
在存储器中，信息是以`字节（8 个二进制位）`为最小存储单位，每一个字节单元分配一个唯一的存储器地址。`8086/8088` CPU 有 
20 根地址线，地址用无符号二进制数表示，但为了方便书写，常用无符号十六进制数（数后加`基数`说明符 `H`）表示。

一个存储单元中存放的信息成为该单元的内容。

          |存储器|
          |      |
    00100H| 27H  |
    00101H| 34H  |
    00102H| 12H  |
    00103H| 68H  |
          |      |

如上图所示，地址是 `00100H` 的字节单元内容为 27H，`00101H` 的字节单元内容为 34H，`00102H` 的字节单元的内容为 12H，
`00103H` 的字节单元的内容为 68H。

    高高低低原则
    一个字数据在存储器中存于相邻的两个字节单元，数据的低字节存入低地址单元，高字节存入高地址单元。

因此，按地址递增方式存储一个数据时，应先存低字节数据，再存高字节数据，这就是通常称为的**“高高低低”**原则，访问
存储器必须遵守该原则，在访问字单元时，一般给出的是字单元的低地址。

例如，在上图中，如果用户要访问地址为 `00100H` 的字单元，则该地址单元所存储的内容为 3427H（低地址为 00100H，高地址
为 00101H）。

要访问一个存储器单元，必须先得到该存储器单元的物理地址。

    物理地址是由段地址和偏移地址合成的。

为什么是段地址和偏移地址呢？

这是由于 `8086/8088` 用于寻址的寄存器都是 16 位（如 `BX` `BP` 等）的，而 16 位的寄存器只能寻址 `64 KB` 的地址范围；
但 `8086/8088` CPU 具有 `20` 根地址线，寻址可达 `1 MB` 地址范围，即 `00000H ~ 0FFFFFH` 范围内的地址。为了能在 16 位
字长的寄存器中提供 20 位地址线，`8086/8088` 采用了存储器分段管理方法。

在介绍存储器分段管理方法之前，先介绍描述存储器地址的 4 个相关术语：

* 物理地址（PA）
* 段首址（SB）
* 偏移地址（EA）
* 逻辑地址（LA）

#### 物理地址（Physical Address）
是由 `8086/8088` 的地址线送出的 20 位地址码。如果 `8086/8088` CPU 要访问存储器任意的一个单元，则必须提供一个 20 位的
二进制数给`地址总线`，才能访问该存储单元。

#### 段首址（Segment Base）
是存储器中每一段的起始地址，又称为`段基址`。

#### 偏移地址（Effective Address）
是相对于`某段首地址`的`段内偏移量`，用 16 位二进制代码表示，写成 4 位十六进制数。

#### 逻辑地址（Logic Address）
是在程序中对存储器地址的一种表示方法，由某段的`段首址`和`段内偏移地址`组成。一般写成：

    段首址：偏移地址

如

    0B47H:0080H

存储器地址分段的具体做法是：

    从 0 地址开始，把 1MB 的存储器空间分成若干段，每 16 字节为一小段，段的起始地址必须是从任一小段的首地址开始；
    也就是说，当一个段开始的物理地址表示成 20 位的二进制地址码时，其最低 4 位是 0 。

每段的最小容量为 `16 B`，最大容量为 `64 KB`。这样，段内地址就可以用 16 位来表示。实际上，可以根据编程的需要来确定
段的大小。它可以是 `64 KB` 范围内的任意多个字节。

存储器采用分段管理后，每个段的首地址（称为`段基地址`或`段地址`）保存在 `8086/8088` 内部的 `CS` `DS` `ES` `SS` 这 4 
个 16 位寄存器中，可以对段寄存器设置不同的值，以指向不同的段。

##### 实模式
16 位的段地址和 16 位的偏移地址组合形成 20 位的物理地址，这就是 `8086/8088` 存储器分段的工作方式，这在 `8086/8088` 的
寻址模式中称为 `实模式`。

##### 8086/8088 存储器物理地址的计算方式
把段首址左移 4 位再加上偏移地址就形成物理地址。

    物理地址 = 段首址 * 16D + 偏移地址

##### 例 2-1 
设有以下 4 组逻辑地址，求它们的物理地址。

1. 0ABCDH:0234H
2. 0FFF0H:00FFH
3. 1234H:0000H
4. 1230H:0040H

**解:** 如果知道`逻辑地址`，则根据公式 ` 物理地址 = 段首址 * 16D + 偏移地址` 可求其对应的物理地址。

① 物理地址 = ABCDH * 16D + 0234H = ABCD0H + 0234H = ABF04H

② 物理地址 = FFF0H * 16D + 00FFH = FFF00H + 00FFH = FFFFFH

③ 物理地址 = 1234H * 16D + 0000H = 12340H + 0000H = 12340H

④ 物理地址 = 1230H * 16D + 0040H = 12300H + 0040H = 12340H

由例可知第③、④小题可知，逻辑地址为 `1234H:0000H` 和逻辑地址为 `1230H:0040H` 所求得的物理地址均为 `12340H`。
即 `8086/8088` `1 MB` 的存储器其每个存储单元的物理地址是唯一的，但是与它对应的逻辑地址可以有很多。

    按照分段方法不难知道，8086/8088 存储器 1 MB 地址空间
    1. 最多可以分为 64 K 个段，每个段均为 16 字节；
    2. 最少可分为 16 个段，每个段均为 64 KB。

### 2.3.2 堆栈
`堆栈`是系统存储器中开辟出的一块特殊区域，用于`保存断点地址`及`需要保存的数据`。其数据的存取原则是 `先进后出`。

堆栈的`固定端`称为`栈底`，`活动端`称为栈顶，数据的存取都是在栈顶进行，堆栈栈顶指针寄存器 `SP` 始终存放栈顶单元的地址，
即 `SP` 始终执行栈顶，跟踪栈顶的变化。

`8086/8088`指令系统有两条堆栈指令（`PUSH` `POP`）专门完成数据的入栈和出栈，具体操作过程将在第 3 章进行详解。

**入栈**

    低地址     |          | 
               |          | 
     ↑         |          | 
    SP →       |  栈顶    | 
               |          | 
               |          | 
               |          | 
               |          | 
               |          | 
               |          | 
    高地址     |  栈底    | 

**出栈**

    低地址     |          | 
               |          | 
               |          | 
    SP →       |  栈顶    | 
     ↓         |          | 
               |          | 
               |          | 
               |          | 
               |          | 
               |          | 
    高地址     |  栈底    | 

**注意**

    堆栈存取必须以字为单位，每次操作后，SP 总是指向新的栈顶。随着数据入栈的增多，堆栈区域将不断扩展，SP 的值不断减小，堆栈的
    栈顶从高地址向低地址方向扩展；随着数据的不断出栈，堆栈区域又将不断缩小，SP 的值不断增大，堆栈栈顶从低地址向高地址方向扩展。

## 2.4 汇编语言程序的调试
一般来说，要完成汇编语言的上机调试，需要用到 `EDIT` 编辑软件、`MASM` 汇编程序、`LINK` 链接程序和 `DEBUG` 调试程序。

### 2.4.1 汇编语言程序
汇编语言程序是由程序员按照汇编语言的各种书写要求编写而成的程序，所以它又被称为 `汇编语言源程序`。如果要将编写好的汇编语言源程序
输入计算机并保存，则一般使用 `EDIT` 编辑程序。汇编语言程序以文件的形式保存到计算机中，该文件的扩展名为 `.ASM`，而主文件名任意。

下面先简单介绍段的定义及概念。

汇编语言程序主要由 4 种基本段组成：

* 代码段
* 数据段
* 堆栈段
* 附加段

其中`代码段`是一个汇编语言程序所必须具备的段，其他段可有可无。即一个代码段就可以构成一个最简单的汇编语言程序。

#### 1. 代码段
代码段是由汇编指令组成的程序段，其各条指令组合起来可完成预定的任务。代码段的首地址由 `CS` 段寄存器指向，偏移量由 `IP` 寄存器指向。

代码段的格式如下：

    段名          SEGMENT
                  .
                  .
                  .
    段名          ENDS

汇编语言规定，每个段都要给出一个段名，作为这个段的名称，并且该段名可以代表该段所在内存的段地址。

段名称的命名规则为：

    采用字母（A~Z a~z）、数字（0~9）、以及专用字符（"?"、"."、"@"、"-"、"$"）组成的字符串。注意，段名不能与系统保留字同名。

段开始语句的定义符是 `SEGMENT` ，段结束语句的定义符是 `ENDS`，两者配合使用。另外，段开始的段名和段结束的段名必须相同。

##### 例 2-2 代码段的定义举例

    CSEG SEGMENT
    	ASSUME CS:CSEG
    START:
    	MOV AX, 1234H				; AX <- 1234H
    	MOV BX, 5678H				; BX <- 5678H
    		.
    		.
    		.
    	MOV AH, 4CH
    	INT 21H						; 返回 DOS
    CSEG ENDS
    END START

该例题给出了一个代码段的定义，该代码段的名称为 CSEG。

#### 2. 数据段
数据段在汇编程序中是可有、可无的。它主要用于定义数据，从而提供给代码段使用。

    代码段主要由指令构成其主体，而数据段则主要由伪指令构成主体。

数据段的段首址由 `DS` 寄存器指向。

数据段的定义类型类似于代码段的定义，定义格式如下：

    段名          SEGMENT
                  .
                  .
                  .
    段名          ENDS

数据段的段名代表了该数据段所在的内存的段地址。

##### 例 2-3 代码段的定义举例

	DSEG SEGMENT
		MESS	DB	12H, 34H, 56H, 78H
		BUFFER	DW	1000H, 2000H, 3000H
		BLOCK	DB	20 DUP(?)
	DSEG ENDS

该例题给出了一个数据段的定义，该数据段的段名为 `DSEG`，并且在数据段中定义了 3 个变量：

* MESS 字节变量
* BUFFER 字变量
* BLOCK 字节变量

#### 3. 堆栈段
堆栈段在汇编语言程序中是可有、可无的，如果在汇编语言程序中没有堆栈段，那么在生成可执行文件时链接程序会发出
警告，但是不会影响程序的执行。

堆栈段一般用于：

* 保存程序的返回地址；
* 在调用子程序时保存各个寄存器的当前值（也称为`保护现场`）；
* 还可以用于传递参数及保存一些变量值。

堆栈段的`段首址`由 `SS` 段寄存器指向，偏移量由 `SP` 寄存器指向。

堆栈段的定义格式如下：

    段名          SEGMENT STACK
                  .
                  .
                  .
    段名          ENDS

在 `SEGMENT` 后加 `STACK` 就可以定义该段为堆栈段。

##### 例 2-4 堆栈段的定义举例

	MYSTACK SEGMENT STACK
		DB 16 DUP(?)
	MYSTACK ENDS


该例题给出了一个堆栈段定义，该堆栈段段名为 `MYSTACK`，并且在堆栈段中定义了一个具有 16 字节的堆栈区域。

#### 4. 附加段
附加段也是用于定义数据，从而提供给代码段使用。附加段的段首址由 `ES` 段寄存器指向。

附加段的定义格式如下：

    段名          SEGMENT
                  .
                  .
                  .
    段名          ENDS

### 2.4.2 汇编程序
当汇编语言程序输入计算机并保存后，必须将该程序编译成计算机能够理解的机器码，这时候就必须使用`汇编程序`（也称`汇编器`）将
扩展名为 `.ASM` 的汇编语言程序汇编成扩展名为 `.OBJ` 的目标文件。

常用的汇编程序有两种：

* MASM 汇编程序 -- IBM 公司的汇编程序
* TASM 汇编程序 -- Borland 公司的汇编器

两者区别不大，本书中采用的是 IBM 公司的 `MASM5.0`。

`MASM5.0` 汇编程序的主要功能是：

1. 检查汇编语言源程序，并展开其中的宏指令；
2. 检查汇编语言源程序中的错误，并给出相应的出错信息；
3. 如果检查没有错误，则生成目标文件（`*.OBJ`），并可给出列表文件（`*.LST`）。

### 2.4.3 链接程序
汇编程序对汇编语言源程序汇编无错后，生成了目标文件，但是目标文件还不是可执行文件（DOS 中可执行文件的扩展名分
别为 `.COM` `.EXE` `.BAT`），所以还必须使用`链接程序 LINK` 将目标文件（`*.OBJ`）链接为可执行文件（`*.LST`）。

### 2.4.4 汇编语言的实验流程
要在计算机上编辑并调试汇编语言程序的步骤是：

1. 用 `EDIT` 编辑程序建立汇编程序源文件（`*.ASM`）；
2. 用 `MASM` 汇编程序把扩展名为 `.ASM` 的汇编程序源文件汇编成目标文件（`*.OBJ`）；
3. 用 `LINK` 链接程序把目标文件链接成可执行文件（`.EXE`）；
4. 使用 `DEBUG` 命令调试结果或直接键入可执行文件的文件名。

### 2.4.5 上机环境的准备
MASM5.0 版本的汇编器内部包含 `MASM.EXE` `LINK.EXE` `LIB.EXE` `DEBUG.EXE` 等文件。MASM5.0 汇编器可以从网站下载。MASM5.0 汇
编器为压缩包形式。

该汇编器无须安装，直接将其解压缩后生成的 `MASM` 文件夹复制到目的地即可。

### 2.4.6 汇编语言程序上机调试过程
观测汇编语言程序的执行结果有两种不同的方法，适用于不同的汇编语言程序。

1. 直接在 DOS 命令下输入该汇编程序的可执行文件名观察结果，如果汇编语言程序运行的结果直接在屏幕上显示，则可以采用该方法；
2. 使用 DEBUG 命令观察程序结果，这种方法适用于汇编语言程序执行后，必须深入观察机器的各个寄存器内容或者存储单元的值。

下面给出两个汇编语言程序上机调试过程实例。其中，例 2-5 采用直接输入文件名观察结果，例 2-6 采用 DEBUG 命令调试法观察结果。

#### 例 2-5 
编写一个汇编语言程序，在屏幕上显示 10 行“This is a Assembly Language Programe.”，并且每行向右缩进一个空格。

**解** 

    该例题属于直接运行程序即可观察结果，所以直接输入其可执行文件名即可。

程序代码如下：

	DSEG SEGMENT
		MESS	DB "This is a Assembly Language Programe.", 0DH, 0AH, "$"		; 显示的字符串
		SPACE	DB " ", "$"						; 显示空格字符，注意 " " 之间有一个空格字符
	DSEG ENDS
	CSEG SEGMENT
		ASSUME CS:CSEG, DS:DSEG
		START:
			MOV AX, DSEG			; 取 DSEG 段首址赋予 AX 寄存器
			MOV DS, AX				; DS <- AX
			MOV BX, 01H				; BX 设置初始化值为 1
		AGAIN:
			MOV DX, OFFSET MESS		; 取显示的字符偏移量赋予 DX
			MOV AH, 09H				; 调用 9 号（显示）DOS 功能子程序
			INT 21H
			MOV CX, BX				; CX <- BX
			INC BX					; BX <- BX + 1
		NEXT:
			MOV DX, OFFSET SPACE	; 取空格字符偏移量赋予 DX
			MOV AH, 09H				; 调用 9 号 DOS 功能子程序，显示空格字符
			INT 21H
			LOOP NEXT				; 继续显示空格字符，直到 CX 为 0
			CMP BX, 10				; BX 与 10 比较
			JBE AGAIN				; 如果没有显示 10 次，则转移到 AGAIN 标号继续执行程序
			MOV AH, 4CH
			INT 21H
	CSEG ENDS
	END START

**汇编源文件**

	Microsoft (R) KKCFUNC ﾊﾞｰｼﾞｮﾝ 1.10
	Copyright (C) Microsoft Corp. 1991,1993. All rights reserved.

	KKCFUNC が組み込まれました.

	マイクロソフトかな漢字変換  ﾊﾞｰｼﾞｮﾝ 2.51
	(C)Copyright Microsoft Corp. 1992-1993
	Microsoft (R) Macro Assembler Version 5.00
	Copyright (C) Microsoft Corp 1981-1985, 1987.  All rights reserved.

	Object filename [2-5.OBJ]:
	Source listing  [NUL.LST]:
	Cross-reference [NUL.CRF]:

	  50016 + 349472 Bytes symbol space free

		  0 Warning Errors
		  0 Severe  Errors

	F:\Books\Assembly\MASM5~1.0>

说明：

* `*.OBJ` -- 这是汇编的主要目的，所以这个文件是我们需要的。当系统询问 `*.OBJ` 文件的文件名时，可直接用回车键回
答，这样就在磁盘上建立了一个 `2-5.OBJ` 的目标文件。
* `*.LST` -- 这个文件列出了源程序和机器语言程序清单，并给出符号列表，因而可使程序调试更加方便。该文件可有、可无。
如果需要，则可输入一个文件名，如输入 `2-5` ，可在磁盘上生成一个 `2-5.LST` 的列表文件；如果不需要生成该文件，则直
接回车即可。

**链接目标文件**

	F:\Books\Assembly\MASM5~1.0>LINK.EXE 2-5.OBJ

	Microsoft (R) Overlay Linker  Version 3.60
	Copyright (C) Microsoft Corp 1983-1987.  All rights reserved.

	Run File [2-5.EXE]:
	List File [NUL.MAP]: 2-5
	Libraries [.LIB]:
	LINK : warning L4021: no stack segment

	F:\Books\Assembly\MASM5~1.0>

由上可知，链接 `2-5.OBJ` 文件后生成两个输出文件，扩展名分别为 `.EXE` 和 `.MAP`，即可执行文件和链接映像文件。如果要将
`2-5.OBJ` 和其他库文件一起链接成可执行文件，则必须输入库文件的文件名。

说明：

* `*.EXE` -- 这是链接的主要目的，所以这个文件是我们需要的。当系统询问 `*.EXE` 文件的文件名时，可直接用回车键回答，这样
就在磁盘上建立了一个 `2-5.EXE` 的目标文件。
* `*.MAP` -- 这个文件列出了每个段在存储器中的分配情况。该文件可有、可无。如果需要，则可输入一个文件名，如输入 `2-5` ，
可在磁盘上生成一个 `2-5.MAP` 的映像文件；如果不需要生成该文件，则直接回车即可。
* `*.LIB` -- 库文件。这个文件是作为 `LINK` 程序的输入文件。如果目标文件 `2-5.OBJ` 需要和某个库文件一起生成可执行文件，
则需要输入库文件的文件名；如果特殊需要，则在 `[.LIB]:` 处直接回车即可。

上面生成的 `2-5.MAP` 文件。

	LINK : warning L4021: no stack segment

	 Start  Stop   Length Name                   Class
	 00000H 00029H 0002AH DSEG                   
	 00030H 00053H 00024H CSEG                   

	Program entry point at 0003:0000

**注意：**

    在源程序代码中，如果没有定义堆栈段，则 LINK 程序在链接过程中会给出一个 "no stack segment" 的提示警告。该警告可忽略。

**运行程序**

	F:\Books\Assembly\MASM5~1.0>2-5
	This is a Assembly Language Programe.
	 This is a Assembly Language Programe.
	  This is a Assembly Language Programe.
	   This is a Assembly Language Programe.
		This is a Assembly Language Programe.
		 This is a Assembly Language Programe.
		  This is a Assembly Language Programe.
		   This is a Assembly Language Programe.
			This is a Assembly Language Programe.
			 This is a Assembly Language Programe.

#### 例 2-6
编写一个汇编程序，实现 `AX` `BX` 内容求和（和为 16 位），并将结果存放于当前数据段的 `SUM` 字单元中（`高地址存储高字节和
低地址存储低字节和`）。

**解析**

    在编写程序之前，设 AX=1234H BX=5678H，它们的和很显然是 68ACH。但该程序运行后用户无法从屏幕直接观察结果。所以
    必须使用 DEBUG 测试改程序，以便观察结果。

程序代码如下：

	DSEG SEGMENT
		SUM DB 2 DUP(?)
	DSEG ENDS
	CSEG SEGMENT
		ASSUME CS:CSEG, DS:DSEG
		START:
			MOV AX, DSEG			; 取 DSEG 段首址赋予 AX 寄存器
			MOV DS, AX				; DS <- AX
			MOV AX, 1234H			; 被加数赋予 AX
			MOV BX, 5678H			; 加数赋予 BX
			ADD AX, BX				; AX <- AX + BX
			MOV SI, OFFSET SUM		; SI <- SUM 单元的偏移量
			MOV [SI], AX			; (SI) <- AX
			MOV AH, 4CH
			INT 21H					; 返回 DOS
	CSEG ENDS
	END START

编译后的 `2-6.MAP` 文件

	LINK : warning L4021: no stack segment

	 Start  Stop   Length Name                   Class
	 00000H 00001H 00002H DSEG                   
	 00010H 00025H 00016H CSEG                   

	Program entry point at 0001:0000

可以看到 `DS` `CS` 相差 16 个字节。在程序载入内存后，也应该呈现此种效果。就是说，当程序被加载到内存中后，如果
数据段`DSEG`被加载到`259D:0000`，那么代码段`CSEG`一定被加载到`259E:0000`。这在下面的调试过程中可以观察到。

**调试过程**

链接成功后，使用 `DEBUG` 命令载入待调试文件。

	F:\Books\Assembly\MASM5~1.0>debug 2-6.EXE
	-u
	259E:0000 B89D25        MOV     AX,259D(数据段地址)
	259E:0003 8ED8          MOV     DS,AX
	259E:0005 B83412        MOV     AX,1234
	259E:0008 BB7856        MOV     BX,5678
	259E:000B 03C3          ADD     AX,BX
	259E:000D BE0000        MOV     SI,0000(SUM 偏移地址)
	259E:0010 8904          MOV     [SI],AX
	259E:0012 B44C          MOV     AH,4C
	259E:0014 CD21          INT     21(程序结束地址)
	259E:0016 7C1C          JL      0034
	259E:0018 7FC6          JG      FFE0
	259E:001A 837E0800      CMP     WORD PTR [BP+08],+00
	259E:001E EBBE          JMP     FFDE
	-G 0014(执行到 0014H)

	AX=4CAC  BX=5678  CX=0026  DX=0000  SP=0000  BP=0000  SI=0000  DI=0000
	DS=259D  ES=258D  SS=259D  CS=259E(可以看到与数据段只差 16 个字节)  IP=0014   NV UP EI PL NZ NA PE NC
	259E:0014 CD21          INT     21
	-D 259D:0000
	259D:0000  AC 68(结果正确) 00 00 00 00 00 00-00 00 00 00 00 00 00 00   .h..............
	259D:0010  B8 9D 25 8E D8 B8 34 12-BB 78 56 03 C3 BE 00 00   ..%...4..xV.....
	259D:0020  89 04 B4 4C CD 21 7C 1C-7F C6 83 7E 08 00 EB BE   ...L.!|....~....
	259D:0030  C4 5E 04 8B 46 0C 26 39-47 0C 74 08 FF 76 0E B8   .^..F.&9G.t..v..
	259D:0040  DC 07 EB B2 C4 5E 04 8B-46 08 8B 56 0A 26 39 57   .....^..F..V.&9W
	259D:0050  0A 7F 19 7C 06 26 39 47-08 73 11 8B 5E 04 8B 46   ...|.&9G.s..^..F
	259D:0060  08 8B 56 0A 26 89 47 08-26 89 57 0A 5D C3 55 8B   ..V.&.G.&.W.].U.
	259D:0070  EC 81 EC 8E 00 56 E9 B0-01 90 A1 22 21 FF 06 22   .....V....."!.."
	-

## 2.5 DEBUG 命令的使用
`DEBUG` 程序是 DOS 支持下的一个测试程序，它具有控制、跟踪程序的执行，设置断点以及显示或修改寄存器或存储器中的数据的功能。

### 2.5.1 U 命令
`U` 命令称为`反汇编命令`，具体使用有以下常用的两种格式：

#### 【格式1】U
* 说明：不带参数的 U 命令。
* 功能：反汇编 32 字节。

以 2-6 程序为例，当在 DOS 下输入 `DEBUG 2-6.EXE` 程序后，直接使用该命令，则改程序其实的 32 字节反汇编将在屏幕上显示。

	F:\Books\Assembly\MASM5~1.0>debug 2-6.EXE
	-U
	259E:0000 B89D25        MOV     AX,259D
	259E:0003 8ED8          MOV     DS,AX
	259E:0005 B83412        MOV     AX,1234
	259E:0008 BB7856        MOV     BX,5678
	259E:000B 03C3          ADD     AX,BX
	259E:000D BE0000        MOV     SI,0000
	259E:0010 8904          MOV     [SI],AX
	259E:0012 B44C          MOV     AH,4C
	259E:0014 CD21          INT     21
	259E:0016 7C1C          JL      0034
	259E:0018 7FC6          JG      FFE0
	259E:001A 837E0800      CMP     WORD PTR [BP+08],+00
	259E:001E EBBE          JMP     FFDE
	程序的段首址:程序的偏移量 
	                        机器码 
	                                汇编指令
	-

由上可知，`U` 命令的显示分为 3 部分：

* 程序所占的存储地址；
* 机器码；
* 反汇编。

应该指出的是

    U 命令反汇编所给出的 32 个字节单元应该包括最后一条指令所占的字节数。

这里，`U` 命令所显示的偏移量为 `0000H~001EH` 单元，但最后一条指令的机器码为 `EBBE`，该机器码共占 4 字节单元，从偏移量
为 `001EH` 单元开始直至 `001FH` 为止，所以 `U` 命令实际上反汇编的地址范围为 `0000H~001FH` 这 32 个字节单元。

#### 【格式2】U 段地址:偏移量
* 说明：带参数的反汇编。
* 功能：从命令给出的`段地址：偏移量`开始反汇编 32 字节。

例如： `U 2000:2000`命令的含义是从段地址为 2000H，偏移量为 2000H（即物理单元 22000H）开始进行反汇编 32 字节，如下所示：

	F:\Books\Assembly\MASM5~1.0>debug
	-U 2000:2000
	2000:2000 64            DB      64
	2000:2001 206279        AND     [BP+SI+79],AH
	2000:2004 0D0A20        OR      AX,200A
	2000:2007 2020          AND     [BX+SI],AH
	2000:2009 2020          AND     [BX+SI],AH
	2000:200B 2020          AND     [BX+SI],AH
	2000:200D 2020          AND     [BX+SI],AH
	2000:200F 2020          AND     [BX+SI],AH
	2000:2011 2020          AND     [BX+SI],AH
	2000:2013 2020          AND     [BX+SI],AH
	2000:2015 2020          AND     [BX+SI],AH
	2000:2017 2020          AND     [BX+SI],AH
	2000:2019 2020          AND     [BX+SI],AH
	2000:201B 2020          AND     [BX+SI],AH
	2000:201D 2020          AND     [BX+SI],AH
	2000:201F 207468        AND     [SI+68],DH
	-

### 2.5.2 G 命令
`G` 命令称为`运行命令`，命令格式如下：

    G 结束地址

* 功能：从当前地址一直执行到 G 命令给出的结束地址。

使用 `G` 命令执行到程序结束地址时，就停止执行并显示当前所有寄存器及标志位内容。

    注意：（？）
    G 命令格式中的结束地址也可以换成程序内部的地址（断点地址），从而可将程序分成不同的几部分分别调试。

### 2.5.3 D 命令
`D` 命令称为`显示存储单元命令`，命令格式如下：

    D 存储单元地址

* 功能：从命令给出的当前地址开始显示，一直显示 8 行存储单元的内容，每行 `16` 个单元，供 `128` 个字节。

使用 `D` 命令一般用于查看存储单元的内容，该命令可查看`代码段`、`数据段`、`附加段`以及`堆栈段`的内容。

**说明：** 

`D`命令与`U`命令其实是一致的，都是显示内存单元内容，而两者之间仅是表现方式不同。

    D 命令注重的是以数据区形式来表现内存所存储的信息。
	U 命令是将各个内存单元的信息以机器码及汇编指令的形式加以体现。

#### 例 2-7 D 命令与 U 命令的关系
**解析** 

编写一个程序，使用 `D` 命令和 `U` 命令观察`代码段`。

程序代码编写如下：

	CSEG SEGMENT
		ASSUME CS:CSEG
		START:
			MOV BX, 1234H
			MOV CX, 5678H
			MOV DX, 0ABCDH
			MOV AH, 4CH
			INT 21H
	CSEG ENDS
	END START

分别使用两种命令观察同一区域，结果如下：

	-U
	252D:0000 BB3412        MOV     BX,1234
	252D:0003 B97856        MOV     CX,5678
	252D:0006 BACDAB        MOV     DX,ABCD
	252D:0009 B44C          MOV     AH,4C
	252D:000B CD21          INT     21
	252D:000D 2895A190      SUB     [DI+90A1],DL
	252D:0011 94            XCHG    SP,AX
	252D:0012 89C2          MOV     DX,AX
	252D:0014 2982F095      SUB     [BP+SI+95F0],AX
	252D:0018 CA82CC        RETF    CC82
	252D:001B 82C682        ADD     DH,82
	252D:001E B182          MOV     CL,82
	-D 252D:0000
	252D:0000  BB 34 12 B9 78 56 BA CD-AB B4 4C CD 21 28 95 A1   .4..xV....L.!(..
	252D:0010  90 94 89 C2 29 82 F0 95-CA 82 CC 82 C6 82 B1 82   ....)...........
	252D:0020  EB 82 D6 83 52 83 73 81-5B 82 B5 82 DC 82 B7 2E   ....R.s.[.......
	252D:0030  0D 0A 0D 0A 43 4F 50 59-20 5B 2F 41 20 7C 20 2F   ....COPY [/A | /
	252D:0040  42 5D 20 91 97 82 E8 91-A4 20 5B 2F 41 20 7C 20   B] ...... [/A |
	252D:0050  2F 42 5D 20 5B 2B 20 91-97 82 E8 91 A4 20 5B 2F   /B] [+ ...... [/
	252D:0060  41 20 7C 20 2F 42 5D 20-5B 2B 20 2E 2E 2E 5D 5D   A | /B] [+ ...]]
	252D:0070  20 5B 8E F3 82 AF 91 A4-0D 0A 20 20 5B 2F 41 20    [........  [/A
	-

不难发现，`U` 命令所显示的机器码和 `D` 命令所显示的单元内容是相同的。也就是说

    U 命令和 D 命令均是显示内存信息，但是 U 命令常用于显示代码段，而 D 命令常用于显示数据段、附加段以及堆栈段。

也可以使用下面这种更加精准的方式显示数据。

	-U 252D:0000 000B
	252D:0000 BB3412        MOV     BX,1234
	252D:0003 B97856        MOV     CX,5678
	252D:0006 BACDAB        MOV     DX,ABCD
	252D:0009 B44C          MOV     AH,4C
	252D:000B CD21          INT     21
	-D 252D:0000 000B
	252D:0000  BB 34 12 B9 78 56 BA CD-AB B4 4C CD               .4..xV....L.

### 2.5.4 R 命令
`R` 命令称为读寄存器命令，具体使用有以下常用的两种格式：

#### 【格式1】R
* 说明：不带参数的 R 命令。
* 功能：显示所有寄存器的当前值及标志位状态。

不带参数的 `R` 命令的使用方法如下所示：

	-R
	AX=0000  BX=0000  CX=000D  DX=0000  SP=0000  BP=0000  SI=0000  DI=0000
	DS=251D  ES=251D  SS=252D  CS=252D  IP=0000   NV UP EI PL NZ NA PO NC
	252D:0000 BB3412        MOV     BX,1234

#### 【格式2】R 寄存器名
* 说明：带参数的 `R` 命令。
* 功能：显示命令中给出的寄存器名的当前值，并可以进行修改。如果直接回车，则不修改寄存器的内容。

    注意：
    寄存器可以为
    1. 段寄存器 -> CS DS ES SS
    2. 标志寄存器 -> FR
    3. 16 位通用寄存器 -> AX BX CX DX SI DI SP BP ，但不允许为 8 为通用寄存器。

带参数的 `R` 命令的使用方法如下所示：

	-R
	AX=0000  BX=0000  CX=000D  DX=0000  SP=0000  BP=0000  SI=0000  DI=0000
	DS=251D  ES=251D  SS=252D  CS=252D  IP=0000   NV UP EI PL NZ NA PO NC
	252D:0000 BB3412        MOV     BX,1234
	-R AX
	AX 0000
	:2000
	-R BX
	BX 0000
	:3000
	-R ES
	ES 251D
	:ABCD
	-R F
	NV UP EI PL NZ NA PO NC  -OV DN EI PO ZR
	-R AL
	br ｴﾗｰ
	-R
	AX=2000  BX=3000  CX=000D  DX=0000  SP=0000  BP=0000  SI=0000  DI=0000
	DS=251D  ES=ABCD  SS=252D  CS=252D  IP=0000   OV DN EI PL ZR NA PO NC
	252D:0000 BB3412        MOV     BX,1234
	-

由上可知，`R` 命令不仅可以显示寄存器的值，还可以修改其内容。这里使用 `R` 命令将全部寄存器的内容及`标志寄存器`的 8 个
状态（`IF 除外`）进行了显示。可以很明显地发现，`AX=2000` `BX=3000` `ES=ABCD`，标志位也发生了明显地改变，这些改变均是
通过 `R` 命令实现的。